{"meta":{"title":"WangGJ's Blog","subtitle":"","description":"","author":"WangGuanjie","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-01-16T02:49:38.000Z","updated":"2022-01-16T02:51:02.366Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-16T03:00:19.000Z","updated":"2022-01-16T03:01:15.444Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"shell实战","slug":"shell实战","date":"2023-11-07T08:32:25.000Z","updated":"2023-11-07T08:40:10.185Z","comments":true,"path":"2023/11/07/shell实战/","link":"","permalink":"http://example.com/2023/11/07/shell%E5%AE%9E%E6%88%98/","excerpt":"","text":"监控某一服务是否正常 端口监控： 1)服务器本地监控命令：netstat，ss，lsof 2)远端监控：telnet，nmap，nc 监控服务进程或进程数：适合本地服务器，grep进程名字12ps -ef|grep mysql # 监控进程ps -ef|grep mysql|wc -l # 监控进程数 在客户端模拟用户访问：使用wget或curl进行测试，对结果进行分析：echo $?","categories":[],"tags":[]},{"title":"os","slug":"os","date":"2023-11-07T02:50:58.000Z","updated":"2023-11-07T02:50:58.019Z","comments":true,"path":"2023/11/07/os/","link":"","permalink":"http://example.com/2023/11/07/os/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"network","slug":"network","date":"2023-11-07T02:50:46.000Z","updated":"2023-11-08T11:06:11.449Z","comments":true,"path":"2023/11/07/network/","link":"","permalink":"http://example.com/2023/11/07/network/","excerpt":"","text":"计算机网络层次结构OSI层次结构及TCP/IP层次结构区别： TCP/IP层次结构中重要协议 网络层网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。数据交换技术是报文交换（基本上被分组所替代）：采用储存转发方式，数据交换单位是报文。主要设备：路由器 网络层主要协议 IP协议（Internet Protocol，因特网互联协议）; ICMP协议（Internet Control Message Protocol，因特网控制报文协议）; ARP协议（Address Resolution Protocol，地址解析协议）; RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 IP协议IP地址IP地址都是由网络前缀和主机号两部分组成，MAC地址称为硬件地址或者物理地址。 两者区别： MAC地址是数据链路层使用的地址 IP地址是网络层和以上各层使用的地址，是一个逻辑地址 IP地址分类A类（8网络号+24主机号）、B类（16网络号+16主机号）、C类（24网络号+8主机号）可以用于标识网络中的主机或路由器，D类地址作为组广播地址，E类是保留地址 网络地址转换NAT技术用于多个主机通过一个公有IP访问访问互联网的私有网络中，减缓了IP地址的消耗，但是增加了网络通信的复杂度。 NAT 工作原理： 从内网出去的IP数据报，将其IP地址替换为NAT服务器拥有的合法的公共IP地址，并将替换关系记录到NAT转换表中； 从公共互联网返回的IP数据报，依据其目的的IP地址检索NAT转换表，并利用检索到的内部私有IP地址替换目的IP地址，然后将IP数据报转发到内部网络。 ARP协议与RARP协议地址解析协议 ARP（Address Resolution Protocol）：为网卡（网络适配器）的IP地址到对应的硬件地址提供动态映射。可以把网络层32位地址转化为数据链路层MAC48位地址。ARP表建立IP地址到MAC地址的映射。 RARP(Reverse Address Resolution Protocol)协议指逆地址解析协议，可以把数据链路层MAC48位地址转化为网络层32位地址。 ICMP协议网际控制报文协议（Internet Control Message Protocol），可以报告错误信息或者异常情况，ICMP报文封装在IP数据报当中。 主要应用： Ping应用：网络故障的排查； Traceroute应用：可以探测IP数据报在网络中走过的路径。 其他协议内部网关协议： RIP(应用层) OSPF(网络层) 外部网关协议： BGP(应用层) 传输层传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；重要设备：网关。 主要协议：TCP和UDP 端口号传输层使用端口号标记不同的网络进程(0-65535) UDPUDP(User Datagram Protocol: 用户数据报协议)，是一个非常简单的协议。 UDP特点： UDP是无连接协议； UDP不能保证可靠的交付数据； UDP是面向报文传输的； UDP没有拥塞控制； UDP首部开销很小。 TCPTCP(Transmission Control Protocol: 传输控制协议) TCP功能： 对应用层报文进行分段和重组； 面向应用层实现复用与分解； 实现端到端的流量控制； 拥塞控制； 传输层寻址； 对收到的报文进行差错检测（首部和数据部分都检错）； 实现进程间的端到端可靠数据传输控制。 TCP特点： TCP是面向连接的协议； TCP是面向字节流的协议； TCP的一个连接有两端，即点对点通信； TCP提供可靠的传输服务； TCP协议提供全双工通信（每条TCP连接只能一对一） TCP标记 建立连接时三次握手为什么需要三次握手？ 第一次握手：客户发送请求，此时服务器知道客户能发； 第二次握手：服务器发送确认，此时客户知道服务器能发能收； 第三次握手：客户发送确认，此时服务器知道客户能收。 第一次：客户向服务器发送连接请求段，建立连接请求控制段（SYN=1），表示传输的报文段的第一个数据字节的序列号是x，此序列号代表整个报文段的序号（seq=x）；客户端进入 SYN_SEND （同步发送状态）； 第二次：服务器发回确认报文段，同意建立新连接的确认段（SYN=1），确认序号字段有效（ACK=1），服务器告诉客户端报文段序号是y（seq=y），表示服务器已经收到客户端序号为x的报文段，准备接受客户端序列号为x+1的报文段（ack_seq=x+1）；服务器由LISTEN进入SYN_RCVD （同步收到状态）; 第三次:客户对服务器的同一连接进行确认.确认序号字段有效(ACK=1),客户此次的报文段的序列号是x+1(seq=x+1),客户期望接受服务器序列号为y+1的报文段(ack_seq=y+1);当客户发送ack时，客户端进入ESTABLISHED 状态;当服务收到客户发送的ack后，也进入ESTABLISHED状态;第三次握手可携带数据. 释放连接时四次挥手 第一次：客户向服务器发送释放连接报文段，发送端数据发送完毕，请求释放连接（FIN=1），传输的第一个数据字节的序号是x（seq=x）；客户端状态由ESTABLISHED进入FIN_WAIT_1（终止等待1状态）； 第二次：服务器向客户发送确认段，确认字号段有效（ACK=1），服务器传输的数据序号是y（seq=y），服务器期望接收客户数据序号为x+1（ack_seq=x+1）;服务器状态由ESTABLISHED进入CLOSE_WAIT（关闭等待）；客户端收到ACK段后，由FIN_WAIT_1进入FIN_WAIT_2； 第三次:服务器向客户发送释放连接报文段，请求释放连接（FIN=1），确认字号段有效（ACK=1），表示服务器期望接收客户数据序号为x+1（ack_seq=x+1）;表示自己传输的第一个字节序号是y+1（seq=y+1）；服务器状态由CLOSE_WAIT 进入 LAST_ACK （最后确认状态）； 第四次：客户向服务器发送确认段，确认字号段有效（ACK=1），表示客户传输的数据序号是x+1（seq=x+1），表示客户期望接收服务器数据序号为y+1+1（ack_seq=y+1+1）；客户端状态由FIN_WAIT_2进入TIME_WAIT，等待2MSL时间，进入CLOSED状态；服务器在收到最后一次ACK后，由LAST_ACK进入CLOSED； 最后需要等待2MSL: 最后一个报文没有确认； 确保发送方的ACK可以到达接收方； 2MSL时间内没有收到，则接收方会重发； 确保当前连接的所有报文都已经过期。 应用层为操作系统或网络应用程序提供访问网络服务的接口。数据传输基本单位为报文。 主要协议： FTP（文件传送协议） Telnet（远程登录协议） DHCP（Dynamic Configuration Protocol:动态主机设置协议） DNS（域名解析协议） SMTP（邮件传送协议） POP3协议（邮局协议） HTTP协议（Hyper Text Transfer Protocol）。 DNS协议DNS（Domain Name System:域名系统）【C/S，UDP，端口53】：解决IP地址复杂难以记忆的问题,存储并完成自己所管辖范围内主机的 域名 到 IP地址 的映射。 域名解析的顺序： 浏览器缓存， 找本机的hosts文件， 路由缓存， 找DNS服务器（本地域名、顶级域名、根域名）-&gt;迭代解析、递归查询。 域名由点、字母和数字组成，分为顶级域（com，cn，net，gov，org）、二级域（baidu,taobao,qq,alibaba）、三级域（www） DHCP协议DHCP（Dynamic Configuration Protocol:动态主机设置协议）：是一个局域网协议，是应用UDP协议的应用层协议。作用：为临时接入局域网的用户自动分配IP地址。 FTP协议文件传输协议（FTP）：控制连接（端口21）：传输控制信息（连接、传输请求），以7位ASCII码的格式。整个会话期间一直打开。 HTTP协议HTTP（HyperText Transfer Protocol:超文本传输协议）【TCP，端口80】：是可靠的数据传输协议，浏览器向服务器发收报文前，先建立TCP连接，HTTP使用TCP连接方式（HTTP自身无连接）。 HTTP请求报文请求方法主要有：GET和POST GET和POST区别 请求位置：GET请求从服务器获取数据，而POST请求向服务器提交数据。 数据传输方式：GET请求通过URL参数传输数据，在URL中附加参数，以?符号开始，参数之间使用&amp;符号连接。例如：http://example.com/page?param1=value1&amp;param2=value2。POST请求将数据包含在请求的主体中，而不是URL中。 请求长度限制：GET请求对URL长度有限制，由浏览器或服务器设定，通常在几千个字符左右。POST请求没有严格的长度限制，可以传输较大的数据量。 数据安全性：GET请求的参数在URL中可见，因此不适合传输敏感信息，如密码等。POST请求的参数在请求主体中，相对于GET请求更安全，但仍然可以通过网络抓包等方式获取数据。 缓存：GET请求可以被缓存，由于GET请求仅用于获取数据，多次相同的GET请求可以返回缓存的结果。POST请求不会被缓存，每次请求都会向服务器提交数据。 幂等性：GET请求是幂等的，即多次发送相同的GET请求不会对服务器造成影响，仅用于获取数据。POST请求不是幂等的，多次发送相同的POST请求会对服务器产生不同的结果，可能会修改服务器上的数据。 GET适用于获取数据，POST适用于提交数据。 HTTP响应报文 响应状态码 1xx：信息提示，表示请求已被成功接收，继续处理。 2xx：请求被成功提交。 3xx：客户端被重定向到其他资源。 4xx：客户端错误状态码，格式错误或者不存在资源。 5xx：描述服务器内部错误。 常用状态码 200：客户端请求成功，是最常见的状态。 302：重定向。 404：请求资源不存在，是最常见的状态。 400：客户端请求有语法错误，不能被服务器所理解。 401：请求未经授权。 403：服务器收到请求，但是拒绝提供服务。 500：服务器内部错误，是最常见的状态。 503：服务器当前不能处理客户端的请求。 HTTPS协议HTTPS(Secure)是安全的HTTP协议，端口号443。基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护。 HTTP和HTTPS的区别 安全性：HTTP是明文传输的协议，数据在传输过程中不加密，容易被窃听和篡改。而HTTPS通过使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对通信进行加密，确保数据的机密性和完整性，提供更高的安全性。 数据传输方式：HTTP使用默认端口80进行通信，而HTTPS使用默认端口443进行通信。HTTP的数据传输是明文的，而HTTPS使用SSL/TLS协议对数据进行加密和解密。 证书要求：HTTPS需要使用SSL证书来验证服务器的身份。SSL证书由可信任的第三方机构颁发，用于确认服务器身份的真实性。这样可以防止中间人攻击（Man-in-the-Middle Attack）和伪装等安全问题。 SEO影响：搜索引擎优化（SEO）方面，HTTPS在搜索引擎中的排名可能更高。搜索引擎（如Google）倾向于将使用HTTPS的网站作为更安全和可信赖的网站对待，因此HTTPS有助于提高网站的可信度和搜索排名。 性能：由于HTTPS的加密和解密过程需要消耗更多的计算资源和时间，因此相对于HTTP而言，HTTPS的性能稍微降低。但是随着计算能力的提升，这种性能差异逐渐减小。 综上所述，HTTPS相比于HTTP提供了更高的安全性和数据保护，适用于对数据传输安全要求较高的场景，如在线支付、用户登录等。对于一般的网页浏览，HTTP已经足够。选择使用HTTP还是HTTPS取决于具体的使用场景和安全需求。","categories":[],"tags":[]},{"title":"shell学习","slug":"shell学习","date":"2023-11-06T12:30:15.000Z","updated":"2023-11-08T11:23:25.532Z","comments":true,"path":"2023/11/06/shell学习/","link":"","permalink":"http://example.com/2023/11/06/shell%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Shebang指定脚本文件的解释器，相当于!#，一般脚本文件的开头是!#/bin/bash 以!#/bin/bash开头的脚本，程序在执行时会调用bin/bash，就是bash解释器 如果未指定shebang，默认用当前shell去执行脚本，即$SHELL shell变量 定义变量时，不能加$. 变量名和等号之间不能有空格！！ 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头. 中间不能有空格，可以使用下划线 &#39;_&#39;. 也可以用命令语句给变量赋值，如：12345for file in `ls /etc` # 返回反引号内的命令结果# 将 /etc 下目录的文件名循环出来for file in $(ls /etc) # 返回$()括号内的命令结果 使用变量使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 123your_name=&quot;wgj&quot;echo $your_nameecho $&#123;your_name&#125; 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 删除变量使用unset删除变量：unset 变量名 变量类型运行shell时，会同时存在三种变量： 局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 shell字符串可以用单引号，双引号，也可以不用引号。 单引号单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 双引号双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 12345678910your_name=&quot;runoob&quot;# 使用双引号拼接greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting $greeting_1# 使用单引号拼接greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;echo $greeting_2 $greeting_3 输出： 12hello, runoob ! hello, runoob !hello, runoob ! hello, $&#123;your_name&#125; ! 获取字符串长度变量为字符串时，`$","categories":[],"tags":[]},{"title":"SoftwareTest","slug":"SoftwareTest","date":"2023-05-08T12:43:38.000Z","updated":"2023-05-08T12:48:12.603Z","comments":true,"path":"2023/05/08/SoftwareTest/","link":"","permalink":"http://example.com/2023/05/08/SoftwareTest/","excerpt":"","text":"软件测试面试问题本文收录软件测试面试过程中常见的面试题.一些问题是从网上搜罗而来,剔除了不合时宜的;一些则是自己总结的面试题.很多的问题是开放性的,并没有确切的标准答案. 目录 常见问题 测试用例设计问题 测试管理问题 自动化测试问题 性能测试问题 数据库问题 操作系统问题 算法问题 数据结构 排序 其它 Java面试题 基础知识 JVM 并发编程 JDBC Servlet&amp;JSP Spring Spring MVC Srping Boot Mybatis 常见问题 软件测试的目的是什么？ 1.为了发现程序中的缺陷，保证软件质量。 2.满足用户需要 软件测试的一般流程是怎么样的？ 1.项目立项后，参加需求评审 2.根据需求文档制定测试用例，然后进行用例评审3.项目提测后，执行用例，问题记录cp4，及时有效的跟进问题的解决情况4.测试环境测试通过后，产品进行验收测试 常见的测试类型有哪些？分别说明一下？ 1.黑盒测试，即常说的功能测试 2.白盒测试，即单元测试，通常由开发来完成，对程序类和方法的测试3.兼容性测试，主要是浏览器的兼容测试4.集成测试，即各个模块的测试5.系统测试，各模块测试完成后，对整个系统的完整性测试6.回归测试7.验收测试 测试用例设计常用的方法有哪些?详细说明一下? 最常用的3种 等价类划分、边界值、场景法 1.等价类划分 分为有效等价类和无效等价类，将测试的范围划分成几个互不相交的子集，从每个子集选出若干个有代表性的值作为测试用例2.边界值：选取正好等于、刚刚大于、刚刚小于边界的3.场景法：划分不同的场景，然后逐一进行验证 解释下单元测试,集成测试,系统测试以及验收测试? 1.单元测试，通常由开发来完成，对程序类和方法的测试 2.集成测试，即各个模块的测试3.系统测试，各模块测试完成后，对整个系统的完整性测试4.验收测试，测试环境测试通过后，由产品或者用户进行验收测试，看看产品的实现，是不是满足了他们当初设计的需求 探索性测试是什么？应该怎么做？ 在需求文档不完善或者压根没有需求文档的情况下，根据经验进行摸索尝试性进行的测试，是测试过程中形成的基本的思维性测试 什么是冒烟测试,如何有效的开展冒烟测试? 1.软件最基本的功能测试，通常由开发完成，只有冒烟点都通过的产品，交由测试，才会比较有意义 2.冒烟测试贯穿于测试的各个阶段，比如集成测试，系统测试等 一条高质量的缺陷记录(Bug)应该具有哪些内容？ 1.记录bug产生的前提条件 2.产生bug的详细操作步骤3.截图，直观的展示问题，有效帮助开发快速定位问题 缺陷的生命周期是怎样的？ 1新建–提交–分配–修复–验证–验证通过关闭–验证不通过reopen Alpha测试与Beta测试的区别？ 1.Alpha测试：把用户请到开发方的场所来测试，用户在模拟实际操作环境下进行的测试，由开发记录下用户反馈的问题 2.beta测试：当开发和测试根本完成时所做的测试，很多不同的用户，在不同的环境下操作，然后用户把产生的问题，定期发给开发者，进行修复（开发不在现场）3.通常现有alpha测试，后有bata测试 你认为做好软件测试应该具备哪些素质？ 1.较好的技术能力 2.对业务逻辑的理解3.良好的沟通能力4.解决和分析事情的能力 作为测试人员,在与开发人员沟通过程中,如何有效的提高沟通效率和效果? 1.耐心的跟开发沟通，跟他阐述不过的重要性 说服他解决问题2.充分尊重对方，哪怕再低级的bug都不要小看他3.宽以待人，设身处地为他人着想 即使开发因为压力或者其他原因不肯合作 也要心平气和的跟他沟通 讨论bug的优先级4.平时多跟开发沟通 无论是工作还是生活上的问题，但是测试一定要有自己的原则 对测试的产品质量负责5.自己先定位问题 帮助开发缩小排查范围 你觉得软件测试工程师在一个团队中，都需要做什么？有什么价值？ 1.在产品需求会上 可以站在用户的角度 提一些贴合用户需求的建议2.测试阶段，根据自己对项目的了解和专业的测试技能 尽可能在项目上线前测出更多问题 保证产品质量3.对测试过程中出现的问题 合理有效的进行风险评估。4.对质量严格把关 测试不通过的 一定不能发布生产 你对软件测试最大的兴趣是什么? 1.行业前景比较好，而且近些年 越来越多企业更注重测试2.测试时间越久 面临的困难和挑战也越多，解决问题的同时 也提高了自身的能力3.自己的性格比较外向开朗 很容易跟产品和开发沟通 做起事情可以事半功倍 你对自己的职业规划是什么？ 先做高级测试有机会的话，想往管理方向发展，目前在携程做测试组长，也为以后管理做储备 在你以往的工作中，发现的影响大或印象深刻的Bug是什么？为什么？ 印象深刻的bug：近期的一个项目，x发单n是发qmq消息，调用发单服务自动发单，测试过程中，我给开发提议加个手动发单–作为发单失败或者未发单的补偿，开发力争 生产不会出现发单失败的情况，但后来还是被我说服，在上线前，加个手动发单的功能。上线第二天，公司qmq框架出现问题，产生消息消费的延迟，导致一段时间内的订单不能自动发单，这时候大家手动发单，解决部分订单，事情过后，开发更加肯定了 我当时的提的bug修复是正确的 在你以往的经历中,解决过的最困难的问题是什么？ 环境问题，是所有测试人员都面临的一个难题；解决的那么多问题中，测试环境无法使用，无法快速的介入测试，仍然是比较突出的。曾经把一个长久未使用的环境，根据经验和clog定位，各个服务之间的调用，一步步完成调通 在你以往的工作或学习中,你最大的收获是什么?学到了什么? 1.业务的积累 2.通过各种自动化，如UI自动化，job自动化，api自动化，不仅提升了自己编码能力，也在每周的常规发布中，起到举足轻重的作用3.长期的测试过程中，提升了自己解决问题的能力 在没有任何文档的情况下,你如何开展测试? 1.尽量的去获取其他的文档吧，比如开发的一 些设计文档—概要设计、功能设计、详细设计 2.尝试从网上找类似的项目文档，如果幸运，可以从公司的资料库找到类似的文档3.按照开发的接口或者设计文档，按照功能模块划分，大致写一些用例，然后进行摸索测试，在测试过程中逐渐完善自己的用例 测试用例设计问题 测试用例是什么？如何设计有效的测试用例？ 为了测试某个产品，编制的一组测试输入、执行条件以及预期结果设计有效的测试用例： 1.明确需求，清晰的知道需求要实现哪些功能2.根据需求文档，拆分出功能点和测试测试要点3.详细的梳理业务需求，设计不同的业务场景，尽可能多的覆盖，尤其重要的逻辑，颗粒度要精细4.具体逻辑的设计方法，遵循边界分析法，出问题最多的就在边界值，然后用等价类划分方法补充一些测试用例5.UI测试，界面元素测试+样式+操作控件设计+浏览器兼容性相关的用例6.时间充足的情况下，设计接口的测试用例，从而保证接口数据的用等价类划分方法补充一些测试用例完整性和正确性–目前携程提倡测试先行的概念，接口要在项目提测前，完成api自动化测试 输入三个整数,判断是否构成有效的三角形,针对这个设计测试用例 首先要设计满足三角形的条件，输入的三个数必须大于0，且同时满足任意两边之和大于第三边。假设三条边是A/B/C，则要满足的条件为A&gt;0，B&gt;0，C&gt;0，A+B&gt;C,A+C&gt;B,B+C&gt;A。以此为例来进行设计即可有效等价类：A&gt;0，B&gt;0，C&gt;0 针对文件上传功能，设计下测试用例 针对网上购物中订单提交的过程，设计测试用例 测试管理问题 你认为测试经理的工作职责和内容是什么？ 1.负责建立和维护一个有效的测试流程; 2.负责测试团队的日常管理工作;3.负责制定和安排测试计划、测试工作;4.带领测试团队进行程序测试工作、按照制定的测试计划执行，并监督和控制测试工作的进程;5.负责测试用例的质量，开发高效的测试用例;6.负责与其他部门的人员沟通协作，例如与开发人员和项目管理人员进行沟通，共同推动项目的顺利进行;7.负责测试团队的培训，培养团队队员的能力。 如果你作为测试Leader,你应该怎么建立公司的测试体系并实施它? 说明你作为测试团队的负责人，如何提高测试团队的技术能力？ 列举你以往项目测试中遇到的风险以及你如何处理的？ 如果当时间不充裕时,该如何安排测试？ 列举你曾经做过的测试(你认为有技术含量的或者提高了测试管理能力的),并说下你从中如何受益？ 在开发和测试存在不合作甚至对立的情况下，你如何平衡和协调工作？ 自动化测试问题 你认为适合做自动化测试的标准是什么? 你认为什么类型的测试不适合做自动化测试? UI自动化测试的优点和缺点分别是什么? 在一个项目中目前还没有进行自动化，如果我想开展自动化测试，我应该怎么做(一般步骤)? 你认为该如何选择最适合的自动化测试工具? 什么是自动化测试框架?一个好的自动化测试框架应该具备什么元素? 说一下你写过的测试框架的代码目录结构是怎么样的? 自动化测试框架的类型有哪些? 说一下你在实施自动化测试过程中好的代码实践? 自动化测试是否仅仅可以是实施在UI层?为什么? 你是否熟悉Selenium工具?说一下它是什么? 你是否还熟悉其它的自动化测试工具?各自简单的介绍一下? 性能测试问题 什么是性能测试?为什么要进行性能测试? 性能测试的类型有哪些? 列举下用户会面对的性能问题和性能瓶颈? 列举下性能测试中常涉及的性能计数? 性能测试中并发用户点击量是什么?如何实现? 性能测试进入和结束的标准是什么? 说一下在选择性能测试工具之前需要考虑哪些东西? 在性能测试中,如何识别性能瓶颈? 在对应用程序进行性能测试期间一般会执行哪些活动? 性能测试中吞吐量是什么? 解释下什么是耐力测试和尖峰测试? 数据库问题MySql 一张表,里面有ID自增主键,当insert了17条记录之后,删除了第15,16,17条记录,再把Mysql重启,再insert一条记录,这条记录的ID是18还是15 操作系统问题 列出超过10个Linux常用的命令以及其作用? 进程和线程是什么?它们有什么区别和联系? 算法问题Java面试题基础知识 面向对象编程有哪些特性? 1.抽象 2.继承 继承是使用已存在的类作为基础–建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率（1）子类拥有父类非private的属性和方法。（2）子类可以拥有自己属性和方法，即子类可以对父类进行扩展。（3）子类可以用自己的方式实现父类的方法学习继承一定少不了这三个东西：构造器、protected关键字、向上转型3.封装(把数据和逻辑封装在类里，通过创建对象去访问这个类里的方法和属性，封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，作用：可以更改好的保护类的内部成员，)4.多态性依赖继承，重写方法同一行为具有不同的实现，通过继承父类，在子类中进行方法的实现通过创建不同子类的对象，去调用不同的方法5.抽象的方法，一定是方法没有方法体的，如：abstract void work()，一定是没有花括号的 重写和重载的区别是什么？为什么重载不能根据返回值判断？ 重写 @Override（不同类），用于子类继承父类，在子类去重写方法，对父类进行扩充或改造ps：父类的方法只有是public或者protected的，子类才能重写方法，其他的如父类是私有或者default，子类都是不可见的，所以不能重写方法子类的方法名，参数，返回值都跟父类相同，重写的方法修饰符大于等于父类的方法重载，同一个类中，存在相同的方法名，但是方法的参数一定不同为什么重载不能根据返回值判断？–答案：因为如果根据返回值判断，那么编译器编译的时候，如果参数相同，就不知道调用哪个方法了 访问修饰符public,private，protected以及默认之间的区别 类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认 抽象类和接口的异同？ Java中的异常有哪几类？分别怎么使用？ 常用的集合类有哪些以及各自有什么特点? ArrayList和LinkedList内部的实现大致是怎样的？他们之间的区别和优缺点？ 内存溢出是怎么回事？请举几个可能出现内存溢出的场景？ ==和equals的区别？ hashCode方法的作用是什么？ HashMap实现原理，如何保证HashMap的线程安全？ Java中一个字符占多少个字节，扩展再问int, long, double占多少字节 创建一个类的实例都有哪些办法？ final/finally/finalize的区别？ String/StringBuffer/StringBuilder的区别? 什么是java序列化，如何实现java序列化? JVM JVM内存结构，为什么需要GC？ JVM堆的基本结构 JVM的垃圾算法有哪几种？CMS垃圾回收的基本流程？ JVM有哪些常用启动参数可以调整，描述几个？ 如何查看JVM的内存使用情况？ 你常用的JVM配置和调优参数都有哪些？分别什么作用？","categories":[],"tags":[]},{"title":"leetcode","slug":"leetcode","date":"2023-04-19T11:29:44.000Z","updated":"2023-04-24T08:09:49.719Z","comments":true,"path":"2023/04/19/leetcode/","link":"","permalink":"http://example.com/2023/04/19/leetcode/","excerpt":"","text":"4.12两数之和自己写的：超出时间限制了 1234567891011121314151617181920class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; res=[] nums=sorted(nums) #题目要求返回下标，不能排序了。 start,end=0,len(nums)-1 while start&lt;end: #可能陷入死循环了 if nums[start]+nums[end]==target: res.append(start) res.append(end) start+=1 #忘记循环加1了，之前就死循环了。 elif nums[start]+nums[end]&lt;target: start+=1 else: end-=1 print(res) 结果：改进： 1234567891011121314class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; res=[] for i in range(0,len(nums)): for j in range(i+1,len(nums)): if nums[i]+nums[j]==target: res.append(i) res.append(j) return res 结果：参考答案： 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; hastable=dict() for i, num in enumerate(nums): if target-num in hastable: return [i,hastable[target-num]] hastable[num]=i return [] 借助哈希表，如果target-nums[i]对应的值不在哈希表中，就将nums[i]和下标i存到哈希表里 遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值 如果存在则找到了两个值，并返回这两个值对应的下标。 三数之和自己写的： 1234567891011121314151617181920class Solution(object): def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; result=[] res=[] for i in range(0,len(nums)): for j in range(i+1,len(nums)): for k in range(j+1,len(nums)): if nums[i]+nums[j]+nums[k]==0: res.append(nums[i]) res.append(nums[j]) res.append(nums[k]) result.append(res) res=[] else:continue print(result) return result 结果：问题：输出的三元组有重复的，如[-1,0,1]和[0,1,-1]，不符合题意。使用了三重循环，时间复杂度较大，有待改进。 参考答案：使用双指针解法，利用排序避免重复答案，头指针start指向第一个元素，尾指针end指向最后一个元素。 12345678910111213141516171819202122232425262728class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums=sorted(nums) print(nums) n = len(nums) ans = [] for first in range(n): if first &gt; 0 and nums[first] == nums[first - 1]:#跳过重复元素 continue if nums[first] &gt; 0: break second, third = first + 1, n - 1 while second &lt; third: target = -(nums[first] + nums[second]) if target &lt; 0: break while second + 1 &lt; third and nums[third] &gt; target: #nums[third] &gt; target，nums[third]偏大，需要向左移动一位 third -= 1 if nums[third] == target: ans.append([nums[first], nums[second], nums[third]]) while second + 1 &lt; third and nums[third] == nums[third - 1]: third -= 1 third -= 1 while second + 1 &lt; third and nums[second] == nums[second + 1]: second += 1 second += 1 return ans 1234567891011121314151617181920212223242526272829303132class Solution(object): def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; dic = dict() res = list() target = 0 for i in nums: #统计nums数组中各个元素的个数 dic[i] = dic.get(i, 0) + 1 n1 = [n for n in dic.keys() if n &lt; 0] #小于0的元素集合 n2 = [n for n in dic.keys() if n &gt; 0] #大于0的元素集合 if 0 in dic and dic[0] &gt;= 3: #nums数组中0元素个数大于3 res.append([0,0,0]) for i in n1: #i指针在小于0的集合中 for j in n2: #j指针在大于0的集合中 k = -i-j # i+j+k=0 if k in dic: if i &lt; k &lt; j: res.append([i,k,j]) elif i &lt;= k &lt; j: #i=k时 if dic[i] &gt;= 2: #如果i的个数大于2 res.append([i,i,j]) elif i &lt; k &lt;= j: #j=k时 if dic[j] &gt;= 2: #如果j的个数大于2 res.append([i, j, j]) return res 12345678910111213141516171819202122232425class Solution: #三重循环解法 def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() #首先利用sort函数对数组进行排序 n = len(nums) #利用len函数得到数组的长度 res = [] #初始化一个返回列表 for i in range(n): #开始外部大循环 tmp = -nums[i] #题目要求三者相加为0，这边就是直接取了负号，后面比较方便 if i &gt; 0 and nums[i] == nums[i - 1]: #如果当前元素和上一个元素相同，则跳过，防止重复解 continue#这里要注意和上一个元素比较，这样子可以避免漏判，有可能出现相邻两个元素全部征用的可能，例如[-2,-2,4] p, q = i + 1, n - 1 #因为i前面的元素作为第一层循环已经遍历过了，这边注意边界条件，防止重复 while p &lt; q: #双指针的循环结束条件，左右指针相遇了 if nums[p] + nums[q] == tmp: #首先判断是否满足条件 res.append([nums[i], nums[p], nums[q]]) #如果满足条件，放到返回列表中 while p &lt; q and nums[p] == nums[p + 1]: #此处用来跳过相同元素，注意比较的方向 p += 1 #如果下一个元素相同，则继续右移 while p &lt; q and nums[q - 1] == nums[q]: #此处用来跳过相同元素，注意比较的方向 q -= 1#如果左边一个元素相同，则继续右移 p += 1 #注意一下如果此时的索引位置符合条件，那么在没有重复的情况下，这两个索引均不能用了，所以此时左右指针同时变化 q -= 1 elif nums[p] + nums[q] &lt; tmp: #因为数组是拍过序的，所以如果小了，左指针右移增大元素 p += 1 else: #因为数组是拍过序的，所以如果大了，右指针左移减小元素 q -= 1 return res #返回结果的res 4.13最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 自己写的：没思路。。。 1234567891011121314151617class Solution(object): def maxSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; sum=0 max=nums[0] for i in range(0,len(nums)): sum+=nums[i] if sum&gt;max: max=sum if sum&lt;0: sum=0 elif sum&lt;0: sum=0 return max 结果： 参考答案： 123456789class Solution(object): def maxSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; for i in range(1,len(nums)): nums[i]=nums[i]+max(nums[i-1],0) return max(nums) 动态规划思想nums[i-1]和nums[i]相加，如果nums[i-1]比0小，那么对于结果无增益效果，nums[i]直接记录结尾为nums[i]的子串的最大值。 4.15搜索旋转排序数组整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 关键：时间复杂度为O(log n)，考虑二分查找。 12345678910111213141516171819202122232425class Solution(object): def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if not nums: return -1 l, r = 0, len(nums) - 1 while l &lt;= r: mid = (l + r) // 2 if nums[mid] == target: return mid if nums[0] &lt;= nums[mid]: # 左边数组有序 if nums[0] &lt;= target &lt; nums[mid]: # target在0到mid之间 r = mid - 1 else: l = mid + 1 else: # 右边数组有序 if nums[mid] &lt; target &lt;= nums[len(nums) - 1]: # target在mid到末尾之间 l = mid + 1 else: r = mid - 1 return -1 买卖股票的最佳时机自己写的：用的暴力解法，结果测试用例中有大数据，超时了。 123456789class Solution: def maxProfit(self, prices: List[int]) -&gt; int: profit=[0]*len(prices) for i in range(0,len(prices)): for j in range(i+1,len(prices)): tmp=prices[j]-prices[i] if tmp&gt;profit[i]: profit[i]=tmp return max(profit) 结果：参考答案： 动态规划思想 记录【今天之前买入的最小值】 计算【今天之前最小值买入，今天卖出的获利】，也即【今天卖出的最大获利】 比较【每天的最大获利】，取最大值即可123456789class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if len(prices)&lt;=1: # prices数组长度小于等于1，直接返回0. return 0 minn,maxn=prices[0],0 # 第一天的价格赋予买入的最小值，第一天最大获利为0 for i in range(1,len(prices)): maxn=max(maxn,prices[i]-minn) # maxn代表今天卖出的最大获利，prices[i]-minn代表如果今天卖出的话，获利多少。 minn=min(minn,prices[i]) # minn代表今天之前买入的最小值 return maxn 合并区间自己并没有什么思路 参考答案： 1234567891011121314class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) # 按照区间的左端点排序，排序后的列表中，可以合并的区间一定是连续的。 merged = [] # merged存储最终的答案 for interval in intervals: # 如果列表为空，或者当前区间与上一区间不重合，直接添加 if not merged or merged[-1][1] &lt; interval[0]: merged.append(interval) else: # 否则的话，我们就可以与上一区间进行合并 merged[-1][1] = max(merged[-1][1], interval[1]) return merged 用数组 merged 存储最终的答案。 首先，将列表中的区间按照左端点升序排序。然后将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间： 如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾； 否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。 4.16下一个排列整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。给你一个整数数组 nums ，找出 nums 的下一个排列。 必须 原地 修改，只允许使用额外常数空间。自己写的： 思路：在数组内倒着找试试？不会实现。。。 参考答案： 思路： 我们希望下一个数 比当前数大，这样才满足 “下一个排列” 的定义。因此只需要 将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。 我们还希望下一个数 增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要： 在 尽可能靠右的低位 进行交换，需要 从后向前 查找 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换 将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列 123456789101112131415161718192021222324252627282930class Solution: def nextPermutation(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # 定义一个将nums中[i,j]区间的元素原地倒排的函数 def reverse(nums,i,j): while(i&lt;j): nums[i],nums[j]=nums[j],nums[i] i+=1 j-=1 # 从右至左找第一个相邻升序对 n=len(nums) firstIndex=-1 for i in range(n-1,-1,-1): if nums[i-1]&lt;nums[i]: firstIndex=i-1 break # 如果没有找到升序对，则数组是降序的，即本身是最大的，所以反转数组，使之成为最小的排列 if firstIndex==-1: reverse(nums,0,n-1) return # 从右至左找第一个大于nums[firstIndex]的大数 secondeIndex=-1 for i in range(n-1,firstIndex,-1): if nums[i]&gt;nums[firstIndex]: secondeIndex=i break nums[firstIndex],nums[secondeIndex]=nums[secondeIndex],nums[firstIndex] reverse(nums,firstIndex+1,n-1) 从前序与中序遍历序列构造二叉树给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 构造二叉树，使用递归。 参考答案： 123456789101112131415161718192021222324252627class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int): if preorder_left &gt; preorder_right: return None # 前序遍历中的第一个节点就是根节点 preorder_root = preorder_left # 在中序遍历中定位根节点 inorder_root = index[preorder[preorder_root]] # 先把根节点建立出来 root = TreeNode(preorder[preorder_root]) # 得到左子树中的节点数目 size_left_subtree = inorder_root - inorder_left # 递归地构造左子树，并连接到根节点 # 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素 root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1) # 递归地构造右子树，并连接到根节点 # 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素 root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right) return root n = len(preorder) # 构造哈希映射，帮助我们快速定位根节点 index = &#123;element: i for i, element in enumerate(inorder)&#125; return myBuildTree(0, n - 1, 0, n - 1) 使用递归函数时，要注意递归函数的边界： 4.18子集给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 参考答案： 方法一：回溯法 12345678910111213141516171819class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: size = len(nums) if size == 0: return [] res = [] self.__dfs(nums, 0, [], res) return res def __dfs(self, nums, start, path, res): # path：递归路径上的数字 res.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) # 因为 nums 不包含重复元素，并且每一个元素只能使用一次 # 所以下一次搜索从 i + 1 开始 self.__dfs(nums, i + 1, path, res) path.pop() # 最后一个数记得pop出来 回溯法：增量构造，类似递归。 方法二：位运算法 数组的每个元素，可以有两个状态： 不在子数组中（用0表示） 在子数组中（用1表示） 123456789101112class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: size = len(nums) n = 1 &lt;&lt; size # 1左移size位，可以用二进制表示数组中的所有数。 res = [] for i in range(n): cur = [] for j in range(size): if i &gt;&gt; j &amp; 1: # nums[j]的二进制表示是否为1 cur.append(nums[j]) res.append(cur) return res 4.19二叉树的层序遍历思路：借用队列完成层序遍历，根节点入队，若他的左右孩子不为none，则依次入队。 123456789101112131415class Solution: def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]: if root == None: return [] # 特判 que = collections.deque([root]) # 双端队列，比用数组模拟队列速度快 ans = [] while len(que) != 0: size = len(que) level = [] for _ in range(size): # 遍历当前层节点 cur = que.popleft() # 从左边弹出队列 level.append(cur.val) # 将当前节点值加入当前层的列表 if cur.left != None: que.append(cur.left) if cur.right != None: que.append(cur.right) ans.append(level) # 将当前层结果加入答案列表 return ans 1234567891011121314151617181920212223class Solution: def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]: que=deque() if root==None: return [] else: que.append(root) # 如果root不为空的话，就将root放到双端队列中 res=[] # 记录最终结果 while True: a=[] # 记录当前层的结果 b=deque() # 构造第二个队列，root出来一个就放到b队列里一个 while len(que)!=0: b.append(que.popleft()) for i in range(len(b)): if b[i]!=None: # 如果b[i]不为none，就将b[i]的值放到当前层的结果中，并将他的左右孩子入队。 a.append(b[i].val) que.append(b[i].left) que.append(b[i].right) if len(a)!=0: res+=[a] if len(que)==0: break return res 二叉树遍历总结 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# 递归# 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。# 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)# 递归1：二叉树遍历最易理解和实现版本class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] # 前序递归 return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right) # # 中序递归 # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) # # 后序递归 # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]# 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: def dfs(cur): if not cur: return # 前序递归 res.append(cur.val) dfs(cur.left) dfs(cur.right) # # 中序递归 # dfs(cur.left) # res.append(cur.val) # dfs(cur.right) # # 后序递归 # dfs(cur.left) # dfs(cur.right) # res.append(cur.val) res = [] dfs(root) return res# 迭代# 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。# 空间复杂度：O(h)，h为树的高度。取决于树的结构，最坏情况存储整棵树，即O(n)# 迭代1：前序遍历最常用模板（后序同样可以用）class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] res = [] stack = [root] # # 前序迭代模板：最常用的二叉树DFS迭代遍历模板 while stack: cur = stack.pop() res.append(cur.val) if cur.right: stack.append(cur.right) if cur.left: stack.append(cur.left) return res # # 后序迭代，相同模板：将前序迭代进栈顺序稍作修改，最后得到的结果反转 # while stack: # cur = stack.pop() # if cur.left: # stack.append(cur.left) # if cur.right: # stack.append(cur.right) # res.append(cur.val) # return res[::-1]# 迭代1：层序遍历最常用模板class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] cur, res = [root], [] while cur: lay, layval = [], [] for node in cur: layval.append(node.val) if node.left: lay.append(node.left) if node.right: lay.append(node.right) cur = lay res.append(layval) return res # 迭代2：前、中、后序遍历通用模板（只需一个栈的空间）class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] stack = [] cur = root # 中序，模板：先用指针找到每颗子树的最左下角，然后进行进出栈操作 while stack or cur: while cur: stack.append(cur) cur = cur.left cur = stack.pop() res.append(cur.val) cur = cur.right return res # # 前序，相同模板 # while stack or cur: # while cur: # res.append(cur.val) # stack.append(cur) # cur = cur.left # cur = stack.pop() # cur = cur.right # return res # # 后序，相同模板 # while stack or cur: # while cur: # res.append(cur.val) # stack.append(cur) # cur = cur.right # cur = stack.pop() # cur = cur.left # return res[::-1] # 迭代3：标记法迭代（需要双倍的空间来存储访问状态）：# 前、中、后、层序通用模板，只需改变进栈顺序或即可实现前后中序遍历，# 而层序遍历则使用队列先进先出。0表示当前未访问，1表示已访问。class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] stack = [(0, root)] while stack: flag, cur = stack.pop() if not cur: continue if flag == 0: # 前序，标记法 stack.append((0, cur.right)) stack.append((0, cur.left)) stack.append((1, cur)) # # 后序，标记法 # stack.append((1, cur)) # stack.append((0, cur.right)) # stack.append((0, cur.left)) # # 中序，标记法 # stack.append((0, cur.right)) # stack.append((1, cur)) # stack.append((0, cur.left)) else: res.append(cur.val) return res # # 层序，标记法 # res = [] # queue = [(0, root)] # while queue: # flag, cur = queue.pop(0) # 注意是队列，先进先出 # if not cur: continue # if flag == 0: # 层序遍历这三个的顺序无所谓，因为是队列，只弹出队首元素 # queue.append((1, cur)) # queue.append((0, cur.left)) # queue.append((0, cur.right)) # else: # res.append(cur.val) # return res# 莫里斯遍历# 时间复杂度：O(n)，n为节点数，看似超过O(n)，有的节点可能要访问两次，实际分析还是O(n)，具体参考大佬博客的分析。# 空间复杂度：O(1)，如果在遍历过程中就输出节点值，则只需常数空间就能得到中序遍历结果，空间只需两个指针。# 如果将结果储存最后输出，则空间复杂度还是O(n)。# PS：莫里斯遍历实际上是在原有二叉树的结构基础上，构造了线索二叉树，# 线索二叉树定义为：原本为空的右子节点指向了中序遍历顺序之后的那个节点，把所有原本为空的左子节点都指向了中序遍历之前的那个节点# emmmm，好像大学教材学过，还考过# 此处只给出中序遍历，前序遍历只需修改输出顺序即可# 而后序遍历，由于遍历是从根开始的，而线索二叉树是将为空的左右子节点连接到相应的顺序上，使其能够按照相应准则输出# 但是后序遍历的根节点却已经没有额外的空间来标记自己下一个应该访问的节点，# 所以这里需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。# 具体参考大佬博客# 莫里斯遍历，借助线索二叉树中序遍历（附前序遍历）class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] # cur = pre = TreeNode(None) cur = root while cur: if not cur.left: res.append(cur.val) # print(cur.val) cur = cur.right else: pre = cur.left while pre.right and pre.right != cur: pre = pre.right if not pre.right: # print(cur.val) 这里是前序遍历的代码，前序与中序的唯一差别，只是输出顺序不同 pre.right = cur cur = cur.left else: pre.right = None res.append(cur.val) # print(cur.val) cur = cur.right return res# N叉树遍历# 时间复杂度：时间复杂度：O(M)，其中 M 是 N 叉树中的节点个数。每个节点只会入栈和出栈各一次。# 空间复杂度：O(M)。在最坏的情况下，这棵 N 叉树只有 2 层，所有第 2 层的节点都是根节点的孩子。# 将根节点推出栈后，需要将这些节点都放入栈，共有 M−1个节点，因此栈的大小为 O(M)。&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val=None, children=None): self.val = val self.children = children&quot;&quot;&quot;# N叉树简洁递归class Solution: def preorder(self, root: &#x27;Node&#x27;) -&gt; List[int]: if not root: return [] res = [root.val] for node in root.children: res.extend(self.preorder(node)) return res# N叉树通用递归模板class Solution: def preorder(self, root: &#x27;Node&#x27;) -&gt; List[int]: res = [] def helper(root): if not root: return res.append(root.val) for child in root.children: helper(child) helper(root) return res# N叉树迭代方法class Solution: def preorder(self, root: &#x27;Node&#x27;) -&gt; List[int]: if not root: return [] s = [root] # s.append(root) res = [] while s: node = s.pop() res.append(node.val) # for child in node.children[::-1]: # s.append(child) s.extend(node.children[::-1]) return res 4.23无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 自己写的： 123456789101112131415161718class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: max_n=0 tmp=0 dict_str=&#123;&#125; if s==&quot;&quot;: return 0 for i in s: dict_str[i]=False print(dict_str) for i in s: if dict_str[i]==True: tmp=0 dict_str[i]=True tmp+=1 if tmp&gt;max_n: max_n=tmp return max_n 错误： 类似dvd这种两边有重复字符，中间的子串就被忽略了。 参考答案： 123456789101112131415161718class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: # 哈希集合，记录每个字符是否出现过 occ = set() n = len(s) # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 rk, ans = -1, 0 for i in range(n): if i != 0: # 左指针向右移动一格，移除一个字符 occ.remove(s[i - 1]) while rk + 1 &lt; n and s[rk + 1] not in occ: # 不断地移动右指针 occ.add(s[rk + 1]) rk += 1 # 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = max(ans, rk - i + 1) return ans 这道题主要用到思路是：滑动窗口 什么是滑动窗口？ 其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！ 如何移动？ 我们只要把队列的左边的元素移出就行了，直到满足题目要求！ 一直维持这样的队列，找出队列出现最长的长度时候，求出解！ 时间复杂度：O(n) 4.24反转链表123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: pre=None node=head while node!=None: nextnode=node.next node.next=pre pre=node node=nextnode return pre # 函数的返回值是ListNode*类型的，所以返回这个链表的头节点就可以了。leetcode会根据这个头节点进行遍历，直至NULL为止。若遍历到的链表与答案一致，则判定正确","categories":[],"tags":[]}],"categories":[],"tags":[]}